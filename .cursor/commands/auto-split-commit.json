{
    "title": "Auto Split & Commit",
    "description": "Analyze working diff, split into logical groups, generate conventional commit messages, stage each group and commit.",
    "prompt": [
      {
        "role": "user",
        "content": "You are an automated commit agent.\n\nTask:\n1. Read the full git diff of the working tree (unstaged + staged).\n2. Split that diff into multiple logical groups (1..N), where a group is a set of changes that belong together by intent (examples: feature code, bugfix, docs, translation, tests, ci, style). Prefer splitting across files and hunks so each commit is focused and atomic. Aim for 2–6 commits unless the diff clearly requires more or fewer.\n3. For each group produce:\n   - A conventional commit header: <type>(<scope>): <short summary>\n   - A concise body that explains what changed and why, lists key files/hunks, and adds a one-line \"Notes:\" with any required docs/translation updates or side-effects.\n   - The explicit git commands to stage only that group's hunks and commit (see staging guidance below).\n\nCommit message rules:\n- Allowed types: feat, fix, refactor, docs, test, chore, style, perf, ci\n- Scope should be a single word or path segment (e.g. auth, api, ui, docs, i18n)\n- Summary ≤ 72 chars, imperative tense.\n- Body explains intent and lists files.\n- If a change affects workflows/statuses/translations/docs → include \"Requires docs update\" or \"Requires translation update\" in the body.\n\nStaging guidance (what to output as commands):\n- Prefer non-destructive, reproducible commands. For each group, output a recommended staging sequence of commands the operator (or automated runner) can run to stage only that group's changes. Use one of these patterns depending on complexity:\n  A) Simple file-level: `git add <file1> <file2> ...` then `git commit -m \"<message>\"`\n  B) Hunk-level (mixed changes in same files): instruct to run `git add -p <file>` and select hunks, then `git commit -m \"<message>\"`.\n  C) If fully automatable, provide `git apply --cached <patch-file>` approach along with the patch content file name.\n\nOutput format (exact):\nFor each commit group output ONLY the following block, separated by a single blank line between groups. DO NOT add any other text or explanation.\n\n---COMMIT START---\nCOMMIT_FILES:\n<comma-separated list of files or \"mixed-hunks: <file1>,<file2>\">\nCOMMIT_HEADER:\n<type>(<scope>): <short summary>\nCOMMIT_BODY:\n<detailed body lines (multiple lines allowed)>\nSTAGING_COMMANDS:\n<one or more shell commands, one per line, to stage & commit this group>\n---COMMIT END---\n\nAfter producing N commit blocks, ALSO output a final single-line summary in this exact form (no other text):\n\nAUTO_SPLIT_RESULT: <N> commits planned\n\nImportant: produce only the blocks and the final summary exactly in the format above. No extra commentary, no filler, no explanation.\n\nDo the analysis now and output the commit blocks and final summary."
      }
    ]
  }
  